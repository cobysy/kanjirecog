{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./example/App.vue?87f9","webpack:///./example/App.vue?3b62","webpack:///./src/Direction.ts","webpack:///./src/Location.ts","webpack:///./src/Stroke.ts","webpack:///./src/PathData.ts","webpack:///./src/InputStroke.ts","webpack:///./src/KanjiInfoDto.ts","webpack:///./src/KanjiInfo.ts","webpack:///./src/KanjiMatch.ts","webpack:///./src/KanjiList.ts","webpack:///./src/StrictComparer.ts","webpack:///./src/FuzzyComparer.ts","webpack:///./src/SpansComparer.ts","webpack:///./src/MatchAlgorithm.ts","webpack:///./example/App.vue","webpack:///./example/App.vue?7a13","webpack:///./example/App.vue?74b3","webpack:///./example/main.ts"],"names":["webpackJsonpCallback","data","moduleId","chunkId","chunkIds","moreModules","executeModules","i","resolves","length","installedChunks","push","Object","prototype","hasOwnProperty","call","modules","parentJsonpFunction","shift","deferredModules","apply","checkDeferredModules","result","deferredModule","fulfilled","j","depId","splice","__webpack_require__","s","installedModules","index","exports","module","l","m","c","d","name","getter","o","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","p","jsonpArray","window","oldJsonpFunction","slice","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0__","_node_modules_mini_css_extract_plugin_dist_loader_js_ref_8_oneOf_1_0_node_modules_css_loader_index_js_ref_8_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_lib_index_js_ref_8_oneOf_1_2_node_modules_sass_loader_lib_loader_js_ref_8_oneOf_1_3_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_App_vue_vue_type_style_index_0_lang_scss___WEBPACK_IMPORTED_MODULE_0___default","Appvue_type_template_id_1ed68c86_render","_vm","this","_h","$createElement","_c","_self","staticClass","directives","rawName","expression","_v","_s","message","isLoading","ref","attrs","size","disabled","clearDisabled","variant","on","click","$event","clear","undoDisabled","undo","algoText","staticStyle","height","_l","res","variantOutline","copyKanji","kanji","staticRenderFns","Direction_Direction","Direction","display","classCallCheck","createClass","other","X","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","directions","iterator","next","done","direction","err","return","Error","startX","startY","endX","endY","threshold","deltaX","deltaY","absDeltaX","Math","abs","absDeltaY","diagonal","DIAGONAL_THRESHOLD","NE","SE","E","NW","SW","W","_diagonal","S","N","DIRECTION_THRESHOLD","Location_Location","Location","x","y","locations","location","MID","Stroke_Stroke","Stroke","previous","fromInts","convert","RangeError","output","trunc","PathData_PathData","PathData","path","remaining","pos","EOL","letter","charAt","NUMBER","substring","start","end","num","parseFloat","isNaN","InputStroke_InputStroke","InputStroke","svgPath","initial","readLetter","readNumber","lastCommand","loop","command","strokes","minX","Number","MAX_VALUE","minY","maxX","MIN_VALUE","maxY","stroke","adjust","_adjust","xRange","yRange","_adjust2","_adjust3","fromFloats","KanjiInfoDto_KanjiInfoDto","KanjiInfoDto","KanjiInfo_KanjiInfo","KanjiInfo","finished","comparers","Map","loadingStrokes","inputStrokes","normalise","findDirections","strokeDirections","strokeStarts","strokeEnds","getDirection","getStartLocation","getEndLocation","moveDirections","_i","getMoveDirection","checkFinished","out","intPos","toString","getTwoDigitPosition","getFullSummary","algo","comparer","newComparer","set","getMatchScore","parseInt","input","parseHex","full","ki","count","offset","getTwoDigitHexInt","e","fromString","_unused","_offset","_i2","KanjiMatch_KanjiMatch","KanjiMatch","kanjiInfo","score","th","strcmp","a","b","KanjiList_KanjiList","KanjiList","kanjiInfos","info","getStrokeCount","list","toConsumableArray","sort","strokeCount","search","values","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","compare","matches","range","countList","match","results","maxScore","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_match","dtos","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","dto","add","fromFull","finish","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","kinfos","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","character","kinfoDto","write","StrictComparer_StrictComparer","StrictComparer","drawnStarts","drawnEnds","drawnDirections","drawnMoves","otherStarts","otherEnds","otherDirections","otherMoves","STROKE_DIRECTION_WEIGHT","isClose","CLOSE_WEIGHT","MOVE_DIRECTION_WEIGHT","STROKE_LOCATION_WEIGHT","max","FuzzyComparer_FuzzyComparer","FuzzyComparer","drawn","drawnPairs","convertKanjiInfo","drawnPoints","getPairPoints","pair","initDrawn","getStroke","FuzzyComparer_Pair","FuzzyComparer_Point","setPair","pairs","Array","point","otherPairs","otherPoints","calcScore","_pair","remainingPairs","pairsLeft","pointsLeft","totalScore","bestPairIndex","bestPair","bestPairScore","scoreAvailable","bestScore","aIndex","bestAIndex","bIndex","bestBIndex","SCOREMULTI_NOT_PAIR","SCOREMULTI_WRONG_DIRECTION","BEST_SCORES_SORT_FIRST","Pair","pointCount","maxBScore","maxAScore","maxStrokes","scores","fill","availablePoints","bScore","aScore","ap","aPair","wrongDirection","_bIndex","_bScore","mustBeOver","sortedScore","aPointIndex","correspondingScores","bPointIndex","FuzzyComparer_ScoreAndIndex","ScoreAndIndex","used","Point","xLess","xMore","xSimilar","yLess","yMore","ySimilar","best","allPoints","SIMILAR_RANGE","preSortedScore","stage1","stage2","stage3","worstBestScore","_i3","thisScore","calcThisScore","pss","bestIndex","stage1a","stage1b","difference","moveIndex","SpansComparer_SpansComparer","SpansComparer","positions","ARRAY_SIZE","SpansComparer_Position","LOCATION_RANGE","addSpan","sX","sY","eX","eY","rightDirection","SCORE_EXACTLOCATION","SCORE_STRAIGHTLOCATION","SCORE_DIAGONALLOCATION","SCORE_RIGHTDIRECTION","getIndex","unmatched","otherCount","otherUnmatched","otherUsed","otherIndexes","requiredScore","MAX_SCORE","MIN_SCORE","NO_MATCH","min","SpansComparer_SpanScore","SpanScore","Position","spanSet","spanScores","minScore","MatchAlgorithm_MatchAlgorithm","MatchAlgorithm","ctor","init","STRICT","FUZZY","FUZZY_1OUT","FUZZY_2OUT","SPANS","SPANS_1OUT","SPANS_2OUT","Appvue_type_script_lang_ts_App","_Vue","App","_this","possibleConstructorReturn","getPrototypeOf","kanjiResults1","kanjiResults2","kanjiResults3","jpws","instr","pad","clearKanjiResults","toData","pop","fromData","hasStrokes","searchKanji","_this2","forEach","kr","potentialKanji","is","addStroke","kanjiList","getTopMatches","console","log","_this3","$nextTick","addEventListener","resizeCanvas","canvas","$refs","signaturePadCanvas","signature_pad_m","onBegin","evt","clientX","clientY","onEnd","fetchKanjiList","then","isFinished","ratio","devicePixelRatio","width","offsetWidth","offsetHeight","getContext","scale","textArea","document","createElement","style","cssText","body","appendChild","select","execCommand","warn","removeChild","Promise","resolve","reject","xhr","XMLHttpRequest","url","open","responseType","send","onload","status","statusText","bin","response","json","pako_default","inflate","Uint8Array","to","JSON","parse","load","getKanji","inherits","vue_property_decorator","tslib_es6","Appvue_type_script_lang_ts_","example_Appvue_type_script_lang_ts_","component","componentNormalizer","options","__file","example_App","vue_runtime_esm","use","es","config","productionTip","render","h","$mount"],"mappings":"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","file":"js/index.599f3d75.js","sourcesContent":[" \t// install a JSONP callback for chunk loading\n \tfunction webpackJsonpCallback(data) {\n \t\tvar chunkIds = data[0];\n \t\tvar moreModules = data[1];\n \t\tvar executeModules = data[2];\n\n \t\t// add \"moreModules\" to the modules object,\n \t\t// then flag all \"chunkIds\" as loaded and fire callback\n \t\tvar moduleId, chunkId, i = 0, resolves = [];\n \t\tfor(;i < chunkIds.length; i++) {\n \t\t\tchunkId = chunkIds[i];\n \t\t\tif(installedChunks[chunkId]) {\n \t\t\t\tresolves.push(installedChunks[chunkId][0]);\n \t\t\t}\n \t\t\tinstalledChunks[chunkId] = 0;\n \t\t}\n \t\tfor(moduleId in moreModules) {\n \t\t\tif(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t}\n \t\tif(parentJsonpFunction) parentJsonpFunction(data);\n\n \t\twhile(resolves.length) {\n \t\t\tresolves.shift()();\n \t\t}\n\n \t\t// add entry modules from loaded chunk to deferred list\n \t\tdeferredModules.push.apply(deferredModules, executeModules || []);\n\n \t\t// run deferred modules when all chunks ready\n \t\treturn checkDeferredModules();\n \t};\n \tfunction checkDeferredModules() {\n \t\tvar result;\n \t\tfor(var i = 0; i < deferredModules.length; i++) {\n \t\t\tvar deferredModule = deferredModules[i];\n \t\t\tvar fulfilled = true;\n \t\t\tfor(var j = 1; j < deferredModule.length; j++) {\n \t\t\t\tvar depId = deferredModule[j];\n \t\t\t\tif(installedChunks[depId] !== 0) fulfilled = false;\n \t\t\t}\n \t\t\tif(fulfilled) {\n \t\t\t\tdeferredModules.splice(i--, 1);\n \t\t\t\tresult = __webpack_require__(__webpack_require__.s = deferredModule[0]);\n \t\t\t}\n \t\t}\n \t\treturn result;\n \t}\n\n \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading chunks\n \t// undefined = chunk not loaded, null = chunk preloaded/prefetched\n \t// Promise = chunk loading, 0 = chunk loaded\n \tvar installedChunks = {\n \t\t\"index\": 0\n \t};\n\n \tvar deferredModules = [];\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/kanjirecog/\";\n\n \tvar jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n \tvar oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n \tjsonpArray.push = webpackJsonpCallback;\n \tjsonpArray = jsonpArray.slice();\n \tfor(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n \tvar parentJsonpFunction = oldJsonpFunction;\n\n\n \t// add entry module to deferred list\n \tdeferredModules.push([0,\"chunk-vendors\"]);\n \t// run deferred modules when ready\n \treturn checkDeferredModules();\n","import mod from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/lib/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"; export default mod; export * from \"-!../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../node_modules/css-loader/index.js??ref--8-oneOf-1-1!../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/lib/index.js??ref--8-oneOf-1-2!../node_modules/sass-loader/lib/loader.js??ref--8-oneOf-1-3!../node_modules/cache-loader/dist/cjs.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=style&index=0&lang=scss&\"","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"outer\"},[_c('div',{staticClass:\"logo\"}),_c('div',{staticClass:\"signature-pad\"},[_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(_vm.isLoading),expression:\"isLoading\"}],staticClass:\"signature-pad-loading\"},[_vm._v(\"\\n            \"+_vm._s(_vm.message)+\"\\n        \")]),_c('div',{directives:[{name:\"show\",rawName:\"v-show\",value:(!_vm.isLoading),expression:\"!isLoading\"}],staticClass:\"signature-pad-main\"},[_c('div',{staticClass:\"signature-pad--body\"},[_c('canvas',{ref:\"signaturePadCanvas\"})]),_c('div',{staticClass:\"signature-pad--footer\"},[_c('div',{staticClass:\"signature-pad--actions\"},[_c('b-button-group',{ref:\"actionsLeft\",attrs:{\"size\":\"sm\"}},[_c('b-button',{attrs:{\"disabled\":_vm.clearDisabled,\"variant\":_vm.variant},on:{\"click\":function($event){_vm.clear()}}},[_vm._v(\"CLEAR\")]),_c('b-button',{attrs:{\"disabled\":_vm.undoDisabled,\"variant\":_vm.variant},on:{\"click\":function($event){_vm.undo()}}},[_vm._v(\"UNDO\")])],1),_c('b-button-group',{attrs:{\"size\":\"sm\"}},[_c('b-button',{ref:\"algoMode\",attrs:{\"variant\":\"700\"}},[_vm._v(_vm._s(_vm.algoText))])],1)],1)]),_c('div',{staticStyle:{\"height\":\"15px\"}}),_c('div',[_c('b-button-group',{attrs:{\"size\":\"sm\"}},_vm._l((_vm.kanjiResults1),function(res){return _c('b-button',{key:res.index,attrs:{\"variant\":_vm.variantOutline},on:{\"click\":function($event){_vm.copyKanji(res.kanji)}}},[_vm._v(\"\\n                        \"+_vm._s(res.kanji)+\"\\n                    \")])})),_c('div',{staticStyle:{\"height\":\"1px\"}}),_c('b-button-group',{attrs:{\"size\":\"sm\"}},_vm._l((_vm.kanjiResults2),function(res){return _c('b-button',{key:res.index,attrs:{\"variant\":_vm.variantOutline},on:{\"click\":function($event){_vm.copyKanji(res.kanji)}}},[_vm._v(\"\\n                        \"+_vm._s(res.kanji)+\"\\n                    \")])})),_c('div',{staticStyle:{\"height\":\"1px\"}}),_c('b-button-group',{attrs:{\"size\":\"sm\"}},_vm._l((_vm.kanjiResults3),function(res){return _c('b-button',{key:res.index,attrs:{\"variant\":_vm.variantOutline},on:{\"click\":function($event){_vm.copyKanji(res.kanji)}}},[_vm._v(\"\\n                        \"+_vm._s(res.kanji)+\"\\n                    \")])}))],1)])])])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","/**\n * The direction of a stroke.\n */\nexport class Direction {\n\n    /** Basically N */\n    public static readonly N = new Direction(0, \"\\u2191\");\n    /** Basically NE */\n    public static readonly NE = new Direction(1, \"\\u2197\");\n    /** Basically E */\n    public static readonly E = new Direction(2, \"\\u2192\");\n    /** Basically SE */\n    public static readonly SE = new Direction(3, \"\\u2198\");\n    /** Basically S */\n    public static readonly S = new Direction(4, \"\\u2193\");\n    /** Basically SW */\n    public static readonly SW = new Direction(5, \"\\u2199\");\n    /** Basically W */\n    public static readonly W = new Direction(6, \"\\u2190\");\n    /** Basically NW */\n    public static readonly NW = new Direction(7, \"\\u2196\");\n    /** No clear movement */\n    public static readonly X = new Direction(-1, \"\\u26aa\");\n\n    private static readonly directions: Direction[] = [Direction.N, Direction.NE, Direction.E, Direction.SE, Direction.S, Direction.SW, Direction.W, Direction.NW, Direction.X];\n\n    constructor(readonly index: number, readonly display: string) { }\n\n    /**\n     * Reads from string.\n     * @param s Input string\n     * @return Direction value\n     * @throws IllegalArgumentException If not a valid direction\n     */\n    public static fromString(s: string): Direction {\n        for (const direction of Direction.directions) {\n            if (direction.display === s) {\n                return direction;\n            }\n        }\n        throw new Error(\"Unknown direction (\" + s + \")\");\n    }\n\n    /**\n     * @param other Another direction\n     * @return True if this direction is within one step of the other direction\n     */\n    public isClose(other: Direction): boolean {\n        if (this === Direction.X || other === Direction.X || this === other) {\n            return true;\n        }\n        return (this.index === ((other.index + 1) % 8))\n            || (((this.index + 1) % 8) === other.index);\n    }\n\n    /**\n     * Threshold above which something counts as directional.\n     */\n    public static readonly DIRECTION_THRESHOLD = 51;\n\n    /**\n     * Propotion (out of 256) of dominant movement required to count as diagonal.\n     * (E.g. if this is 77 = approx 30%, and if movement S is 10, then movenent E must\n     * be at least 10 * 77 / 256 in order to count as SE).\n     */\n    public static readonly DIAGONAL_THRESHOLD = 77;\n\n    /**\n     * Calculates the direction between two points.\n     * @param startX Start X\n     * @param startY Start Y\n     * @param endX End X\n     * @param endY End Y\n     * @param threshold Direction threshold (movement under this is not counted as directional)\n     * @return Direction of stroke\n     * @throws IllegalStateException If not normalised\n     */\n    public static get(startX: number, startY: number,\n                      endX: number, endY: number, threshold: number): Direction {\n        // Get movement in each direction\n        const deltaX = endX - startX, deltaY = endY - startY;\n\n        // Check if it's not really movement at all (under threshold)\n        const absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY);\n        if (absDeltaX < threshold && absDeltaY < threshold) {\n            return Direction.X;\n        }\n\n        if (absDeltaX > absDeltaY) {\n            // X movement is more significant\n            const diagonal = absDeltaY > ((Direction.DIAGONAL_THRESHOLD * absDeltaX) >> 8);\n            if (deltaX > 0) {\n                if (diagonal) {\n                    return deltaY < 0 ? Direction.NE : Direction.SE;\n                } else {\n                    return Direction.E;\n                }\n            } else {\n                if (diagonal) {\n                    return deltaY < 0 ? Direction.NW : Direction.SW;\n                } else {\n                    return Direction.W;\n                }\n            }\n        } else {\n            // Y movement is more significant\n            const diagonal = absDeltaX > ((Direction.DIAGONAL_THRESHOLD * absDeltaY) >> 8);\n            if (deltaY > 0) {\n                if (diagonal) {\n                    return deltaX < 0 ? Direction.SW : Direction.SE;\n                } else {\n                    return Direction.S;\n                }\n            } else {\n                if (diagonal) {\n                    return deltaX < 0 ? Direction.NW : Direction.NE;\n                } else {\n                    return Direction.N;\n                }\n            }\n        }\n    }\n}\n","/**\n * Represents approximate location of start/end points of stroke.\n */\nexport class Location {\n\n    /** Basically N */\n    public static readonly N = new Location(1, 0, \"\\u2580\");\n    /** Basically NE */\n    public static readonly NE = new Location(2, 0, \"\\u259c\");\n    /** Basically E */\n    public static readonly E = new Location(2, 1, \"\\u2590\");\n    /** Basically SE */\n    public static readonly SE = new Location(2, 2, \"\\u259f\");\n    /** Basically S */\n    public static readonly S = new Location(1, 2, \"\\u2584\");\n    /** Basically SW */\n    public static readonly SW = new Location(0, 2, \"\\u2599\");\n    /** Basically W */\n    public static readonly W = new Location(0, 1, \"\\u258c\");\n    /** Basically NW */\n    public static readonly NW = new Location(0, 0, \"\\u259b\");\n    /** Basically in the middle */\n    public static readonly MID = new Location(1, 1, \"\\u2588\");\n\n    private static readonly locations: Location[] = [Location.N, Location.NE, Location.E, Location.SE, Location.S, Location.SW, Location.W, Location.NW, Location.MID];\n\n    constructor(readonly x: number, readonly y: number, readonly display: string) {}\n\n    /**\n     * Reads from string.\n     * @param s Input string\n     * @return Location value\n     * @throws IllegalArgumentException If not a valid direction\n     */\n    public static fromString(s: string): Location {\n        for (const location of Location.locations) {\n            if (location.display === s) {\n                return location;\n            }\n        }\n        throw new Error(\"Unknown location (\" + s + \")\");\n    }\n\n    /**\n     * @param other Another location\n     * @return True if this location is within one step of the other location\n     */\n    public isClose(other: Location): boolean {\n        return Math.abs(this.x - other.x) <= 1 && Math.abs(this.y - other.y) <= 1;\n    }\n\n    /**\n     * @param x Normalised X\n     * @param y Normalised Y\n     * @return Location\n     */\n    public static get(x: number, y: number): Location {\n        if (x < 85) {\n            if (y < 85) {\n                return Location.NW;\n            } else if (y < 170) {\n                return Location.W;\n            } else {\n                return Location.SW;\n            }\n        } else if (x < 170) {\n            if (y < 85) {\n                return Location.N;\n            } else if (y < 170) {\n                return Location.MID;\n            } else {\n                return Location.S;\n            }\n        } else {\n            if (y < 85) {\n                return Location.NE;\n            } else if (y < 170) {\n                return Location.E;\n            } else {\n                return Location.SE;\n            }\n        }\n    }\n}\n\n// console.log(Location.locations);\n","import { Direction } from \"./Direction\";\nimport { Location } from \"./Location\";\n\n/**\n * Single kanji stroke.\n */\nexport class Stroke {\n\n    // All values in range 0-255\n    public startX: number;\n    public startY: number;\n    public endX: number;\n    public endY: number;\n\n    /**\n\t * Constructs from float data.\n\t * @param startX Start position (x) 0-1\n\t * @param startY Start position (y) 0-1\n\t * @param endX End position (x) 0-1\n\t * @param endY End position (y) 0-1\n\t * @throws IllegalArgumentException If any value out of range\n\t */\n    public static fromFloats(startX: number, startY: number,\n                             endX: number, endY: number): Stroke {\n        return this.fromInts(this.convert(startX),\n            this.convert(startY),\n            this.convert(endX),\n            this.convert(endY));\n    }\n\n    public static fromInts(startX: number, startY: number,\n                           endX: number, endY: number): Stroke {\n        if (startX < 0 || startX > 255 || startY < 0 || startY > 255\n            || endX < 0 || endX > 255 || endY < 0 || endY > 255) {\n            throw new RangeError(\"Value out of range\");\n        }\n        const output = new this();\n        output.startX = startX;\n        output.startY = startY;\n        output.endX = endX;\n        output.endY = endY;\n        return output;\n    }\n\n    private static convert(value: number): number {\n        return Math.trunc(value * 255 + 0.49999);\n    }\n\n    /**\n\t * Calculates the direction of this stroke.\n\t * @return Direction of stroke\n\t */\n    public getDirection(): Direction {\n        return Direction.get(this.startX, this.startY, this.endX, this.endY,\n            Direction.DIRECTION_THRESHOLD);\n    }\n\n    /**\n\t * Calculates the direction of this stroke without imposing a threshold\n\t * that considers short moves as nondirectional.\n\t * @return Direction of stroke (will not be Direction.X)\n\t */\n    public getDirectionNoThreshold(): Direction {\n        return Direction.get(this.startX, this.startY, this.endX, this.endY, 0);\n    }\n\n    /**\n\t * Calculates the direction that the pen moved between the end of the\n\t * last stroke and the start of this one.\n\t * @param previous Previous stroke\n\t * @return Direction moved\n\t */\n    public getMoveDirection(previous: Stroke): Direction {\n        return Direction.get(previous.endX, previous.endY, this.startX, this.startY,\n            Direction.DIRECTION_THRESHOLD);\n    }\n\n    /**\n\t * @return Approximate location of start of stroke\n\t */\n    public getStartLocation(): Location {\n        return Location.get(this.startX, this.startY);\n    }\n\n    /**\n\t * @return Approximate location of end of stroke\n\t */\n    public getEndLocation(): Location {\n        return Location.get(this.endX, this.endY);\n    }\n\n    public toString(): string {\n        return \"[\" + this.startX + \",\" + this.startY + \":\" + this.endX + \",\" + this.endY + \"]\";\n    }\n}\n","/**\n * Class to make it easier to read path data.\n */\nexport class PathData {\n    public static EOL = \"-1\";\n    public static NUMBER = \"-2\";\n\n    private remaining: string;\n    constructor(path: string) {\n        this.remaining = path;\n    }\n\n    /**\n     * Reads the next non-whitespace character.\n     * @return Character or EOL if end of string or NUMBER if number/comma not letter\n     */\n    public readLetter(): string {\n        let pos = 0;\n        while (true) {\n            if (pos === this.remaining.length) {\n                return PathData.EOL;\n            }\n            const letter = this.remaining.charAt(pos);\n            if (letter !== \" \") {\n                if (letter === \",\" || letter === \"-\" || letter === \"+\" || (letter >= \"0\" && letter <= \"9\")) {\n                    return PathData.NUMBER;\n                }\n                this.remaining = this.remaining.substring(pos + 1);\n                return letter;\n            }\n            pos++;\n        }\n    }\n\n    /**\n     * Reads the next number, skipping whitespace and comma and +\n     * @return Number\n     * @throws IllegalArgumentException If unexpected EOL or invalid number\n     */\n    public readNumber(): number {\n        let start = 0;\n        while (true) {\n            if (start === this.remaining.length) {\n                throw new Error(\"Unexpected EOL before number\");\n            }\n            const c = this.remaining.charAt(start);\n            if (c !== \",\" && c !== \" \" && c !== \"+\") {\n                break;\n            }\n            start++;\n        }\n\n        let end = start + 1;\n        while (true) {\n            if (end === this.remaining.length) {\n                break;\n            }\n            const c = this.remaining.charAt(end);\n            if (c !== \".\" && (c < \"0\" || c > \"9\")) {\n                break;\n            }\n            end++;\n        }\n\n        const num = this.remaining.substring(start, end);\n        this.remaining = this.remaining.substring(end);\n\n        const n = parseFloat(num);\n        if (isNaN(n)) {\n            throw new Error(\"Invalid number: \" + num);\n        }\n\n        return n;\n    }\n}\n","import { Stroke } from \"./Stroke\";\nimport { PathData } from \"./PathData\";\n\nexport class InputStroke {\n\n    public startX: number;\n    public startY: number;\n    public endX: number;\n    public endY: number;\n\n    /**\n    * Constructs from an SVG path. The full SVG path sequence is not accepted.\n    * Instead all paths must begin with a single M or m followed by commands from\n    * the following list: \"CcSsZz\"\n    * @param svgPath SVG path string\n    * @throws IllegalArgumentException If string can't be parsed\n    */\n    public static fromSvgPath(svgPath: string) {\n        const output = new InputStroke();\n\n        const data = new PathData(svgPath);\n\n        // Read initial M\n        const initial = data.readLetter();\n        if (initial !== \"M\" && initial !== \"m\") {\n            throw new Error(\"Path must start with M\");\n        }\n\n        // Read start co-ordinates (note: 'm' is not really relative at start\n        // of path, so treated the same as M; see SVG spec)\n        output.startX = data.readNumber();\n        output.startY = data.readNumber();\n\n        // Handle all other commands\n        let x = output.startX;\n        let y = output.startY;\n        let lastCommand = \"-1\";\n        loop: while (true) {\n            let command = data.readLetter();\n            if (command === PathData.NUMBER) {\n                if (lastCommand === \"-1\") {\n                    throw new Error(\"Expecting command, not number\");\n                }\n                command = lastCommand;\n            } else {\n                lastCommand = command;\n            }\n            switch (command) {\n                case PathData.EOL:\n                    break loop; // End of line\n                case \"c\":\n                    data.readNumber();\n                    data.readNumber();\n                    data.readNumber();\n                    data.readNumber();\n                    x += data.readNumber();\n                    y += data.readNumber();\n                    break;\n                case \"C\":\n                    data.readNumber();\n                    data.readNumber();\n                    data.readNumber();\n                    data.readNumber();\n                    x = data.readNumber();\n                    y = data.readNumber();\n                    break;\n                case \"s\":\n                    data.readNumber();\n                    data.readNumber();\n                    x += data.readNumber();\n                    y += data.readNumber();\n                    break;\n                case \"S\":\n                    data.readNumber();\n                    data.readNumber();\n                    x = data.readNumber();\n                    y = data.readNumber();\n                    break;\n                case \"z\":\n                case \"Z\":\n                    x = output.startX;\n                    y = output.startY;\n                    break;\n                default:\n                    throw new Error(\"Unexpected path command: \" + command);\n            }\n        }\n\n        output.endX = x;\n        output.endY = y;\n        return output;\n    }\n\n    /**\n\t * Constructs from raw data.\n\t * @param startX Start position (x) 0-1\n\t * @param startY Start position (y) 0-1\n\t * @param endX End position (x) 0-1\n\t * @param endY End position (y) 0-1\n\t */\n    public static fromFloats(startX: number, startY: number, endX: number, endY: number) {\n        const output = new InputStroke();\n        output.startX = startX;\n        output.endX = endX;\n        output.startY = startY;\n        output.endY = endY;\n        return output;\n    }\n\n    /**\n\t * Normalises an array of strokes by converting their co-ordinates to range\n\t * from 0 to 1 in each direction. If the stroke bounding rectangle\n\t * has width or height 0, this will be handled so that it is at 0.5 in\n\t * the relevant position.\n\t * <p>\n\t * This works by constructing new stroke objects; strokes are final.\n\t * @param strokes Stroke array to convert\n\t * @return Resulting converted array\n\t */\n    public static normalise(strokes: InputStroke[]): Stroke[] {\n        // Find range\n        let minX = Number.MAX_VALUE;\n        let minY = Number.MAX_VALUE;\n        let maxX = Number.MIN_VALUE;\n        let maxY = Number.MIN_VALUE;\n\n        for (const stroke of strokes) {\n            if (stroke.startX < minX) {\n                minX = stroke.startX;\n            }\n            if (stroke.startX > maxX) {\n                maxX = stroke.startX;\n            }\n            if (stroke.startY < minY) {\n                minY = stroke.startY;\n            }\n            if (stroke.startY > maxY) {\n                maxY = stroke.startY;\n            }\n\n            if (stroke.endX < minX) {\n                minX = stroke.endX;\n            }\n            if (stroke.endX > maxX) {\n                maxX = stroke.endX;\n            }\n            if (stroke.endY < minY) {\n                minY = stroke.endY;\n            }\n            if (stroke.endY > maxY) {\n                maxY = stroke.endY;\n            }\n        }\n\n        // Adjust max/min to avoid divide by zero\n        if (Math.abs(minX - maxX) < 0.0000000001) {\n            // Adjust by 1% of height\n            let adjust = Math.abs(minY - maxY);\n            if (adjust < 0.0000000001) {\n                adjust = 0.1;\n            }\n            minX -= adjust;\n            maxX += adjust;\n        }\n        if (Math.abs(minY - maxY) < 0.0000000001) {\n            // Adjust by 1% of width\n            let adjust = Math.abs(minX - maxX) / 100;\n            if (adjust < 0.0000000001) {\n                adjust = 0.1;\n            }\n\n            minY -= adjust;\n            maxY += adjust;\n        }\n\n        // Now sort out a maximum scale factor, so that very long/thin kanji\n        // don't get stretched to square\n        const xRange = Math.abs(minX - maxX);\n        const yRange = Math.abs(minY - maxY);\n        if (xRange > 5 * yRange) {\n            const adjust = (xRange - yRange) / 2;\n            minY -= adjust;\n            maxY += adjust;\n        } else if (yRange > 5 * xRange) {\n            const adjust = (yRange - xRange) / 2;\n            minX -= adjust;\n            maxX += adjust;\n        }\n\n        // Convert all points according to range\n        const output: Stroke[] = [];\n        for (let i = 0; i < strokes.length; i++) {\n            output[i] = Stroke.fromFloats(\n                (strokes[i].startX - minX) / (maxX - minX),\n                (strokes[i].startY - minY) / (maxY - minY),\n                (strokes[i].endX - minX) / (maxX - minX),\n                (strokes[i].endY - minY) / (maxY - minY));\n        }\n\n        return output;\n    }\n}\n","// tslint:disable-next-line:max-classes-per-file\nexport class KanjiInfoDto {\n    constructor(readonly kanji: string, readonly strokes: string) {}\n}\n","import { InputStroke } from \"./InputStroke\";\nimport { Stroke } from \"./Stroke\";\nimport { Direction } from \"./Direction\";\nimport { Location } from \"./Location\";\nimport { MatchAlgorithmKey, MatchAlgorithm } from \"./MatchAlgorithm\";\nimport { IKanjiComparer } from \"./KanjiComparer\";\nimport { KanjiInfoDto } from \"./KanjiInfoDto\";\n\nexport class KanjiInfo {\n\n    private loadingStrokes: InputStroke[];\n    private strokes: Stroke[];\n    private finished = false;\n    public strokeDirections: Direction[];\n    public moveDirections: Direction[];\n    public strokeStarts: Location[];\n    public strokeEnds: Location[];\n    private comparers = new Map<MatchAlgorithmKey, IKanjiComparer>();\n\n    public static parseHex(s: string): number {\n        const n = parseInt(s, 16);\n        if (!isNaN(n)) {\n            return n;\n        }\n        throw new Error(\"NumberFormatException \" + s);\n    }\n\n    /**\n\t * Converts a two-digit, lowercase hex string to an integer. (This is a lot\n\t * faster than doing a substring and Integer.parseInt; I profiled it and\n\t * saw a big performance improvement to the overall load process.)\n\t * @param input String\n\t * @param pos Position in string of first digit\n\t * @return Value as integer\n\t */\n    public static getTwoDigitHexInt(input: string, pos: number): number {\n        return this.parseHex(input.substring(pos, pos + 2));\n    }\n\n    /**\n\t * @param kanji Kanji character (should be a single character, but may be\n\t *   a UTF-16 surrogate pair)\n\t */\n    constructor(readonly kanji: string) {\n        this.loadingStrokes = [];\n    }\n\n    public static fromFull(kanji: string, full: string): KanjiInfo {\n        const ki = new this(kanji);\n\n        const count = (full.length + 1) / 12;\n        if ((count * 12 - 1) !== full.length) {\n            throw new Error(\"Invalid full (\" + full\n                + \") for kanji (\" + kanji + \")\");\n        }\n\n        try {\n            ki.strokes = [];\n            let offset = 0;\n            for (let i = 0; i < count; i++) {\n                if (i !== 0) {\n                    offset++; // Skip colon\n                }\n\n                ki.strokes[i] = Stroke.fromInts(\n                    this.getTwoDigitHexInt(full, offset),\n                    this.getTwoDigitHexInt(full, offset + 3),\n                    this.getTwoDigitHexInt(full, offset + 6),\n                    this.getTwoDigitHexInt(full, offset + 9));\n                offset += 11;\n            }\n\n        } catch (e) {\n            throw new Error(\"Invalid summary(\" + full\n                + \") for kanji (\" + kanji + \")\" + e);\n        }\n\n        ki.findDirections();\n\n        return ki;\n    }\n\n    /**\n\t * @param kanji Kanji character (should be a single character, but may be\n\t *   a UTF-16 surrogate pair)\n\t * @param directions Strokes string (in {@link #getAllDirections()} format)\n\t * @param full Full summary string (in {@link #getFullSummary()} format)\n\t * @throws IllegalArgumentException If strokes string has invalid format\n\t */\n    public static fromDirectionsFull(kanji: string, directions: string, full: string): KanjiInfo {\n        const ki = new this(kanji);\n        const count = (full.length + 1) / 12;\n        if (count < 1 || (count * 6 - 3) !== directions.length) {\n            throw new Error(\"Invalid directions (\" + directions\n                + \") for kanji (\" + kanji + \")\");\n        }\n        if ((count * 12 - 1) !== full.length) {\n            throw new Error(\"Invalid full (\" + full\n                + \") for kanji (\" + kanji + \")\");\n        }\n\n        ki.strokeDirections = [];\n        ki.strokeStarts = [];\n        ki.strokeEnds = [];\n        ki.moveDirections = [];\n\n        try {\n            let offset = 0;\n            for (let i = 0; i < count; i++) {\n                if (i !== 0) {\n                    offset++; // Skip colon\n                    ki.moveDirections[i - 1] = Direction.fromString(directions.charAt(offset++) + \"\");\n                    offset++; // Skip colon\n                }\n\n                ki.strokeStarts[i] = Location.fromString(directions.charAt(offset++) + \"\");\n                ki.strokeDirections[i] = Direction.fromString(directions.charAt(offset++) + \"\");\n                ki.strokeEnds[i] = Location.fromString(directions.charAt(offset++) + \"\");\n            }\n        } catch {\n            throw new Error(\"Invalid strokes(\" + directions\n                + \") for kanji (\" + kanji + \")\");\n        }\n\n        try {\n            ki.strokes = [];\n            let offset = 0;\n            for (let i = 0; i < count; i++) {\n                if (i !== 0) {\n                    offset++; // Skip colon\n                }\n\n                ki.strokes[i] = Stroke.fromInts(\n                    this.parseHex(full.substring(offset, offset + 2)),\n                    this.parseHex(full.substring(offset + 3, offset + 5)),\n                    this.parseHex(full.substring(offset + 6, offset + 8)),\n                    this.parseHex(full.substring(offset + 9, offset + 11)));\n                offset += 11;\n            }\n        } catch (e) {\n            throw new Error(\"Invalid summary(\" + full\n                + \") for kanji (\" + kanji + \")\" + e);\n        }\n\n        return ki;\n    }\n\n    /**\n\t * Adds a stroke. Can only be called during initialisation.\n\t * @param stroke New stroke\n\t * @throws IllegalStateException If already finished\n\t */\n    public addStroke(stroke: InputStroke) {\n        if (this.loadingStrokes == null) {\n            throw new Error(\"Cannot add strokes after loading\");\n        }\n        this.loadingStrokes.push(stroke);\n    }\n\n    /**\n\t * Marks kanji as finished, normalising all strokes.\n\t * @throws IllegalStateException If already finished\n\t */\n    public finish() {\n        if (this.finished) {\n            throw new Error(\"Cannot finish more than once\");\n        }\n\n        // Get stroke array and normalise it\n        const inputStrokes = this.loadingStrokes;\n\n        this.strokes = InputStroke.normalise(inputStrokes);\n\n        // Find directions\n        this.findDirections();\n    }\n\n    /**\n\t * Calculate the direction summary.\n\t */\n    private findDirections() {\n        // Find all the directions\n        this.strokeDirections = [];\n        this.strokeStarts = [];\n        this.strokeEnds = [];\n        for (let i = 0; i < this.strokes.length; i++) {\n            this.strokeDirections[i] = this.strokes[i].getDirection();\n            this.strokeStarts[i] = this.strokes[i].getStartLocation();\n            this.strokeEnds[i] = this.strokes[i].getEndLocation();\n        }\n        this.moveDirections = [];\n        for (let i = 1; i < this.strokes.length; i++) {\n            this.moveDirections[i - 1] = this.strokes[i].getMoveDirection(this.strokes[i - 1]);\n        }\n\n        this.finished = true;\n    }\n\n    /**\n\t * Checks that this kanji has been finished.\n\t * @throws IllegalStateException If not finished\n\t */\n    private checkFinished() {\n        if (!this.finished) {\n            throw new Error(\"Cannot call on unfinished kanji\");\n        }\n    }\n\n    /**\n\t * @return Stroke count\n\t * @throws IllegalStateException If not finished\n\t */\n    public getStrokeCount(): number {\n        this.checkFinished();\n        return this.strokeDirections.length;\n    }\n\n    /**\n\t * @param index Stroke index\n\t * @return Stroke\n\t * @throws ArrayIndexOutOfBoundsException If index >=\n\t *   {@link #getStrokeCount()}\n\t * @throws IllegalStateException If loaded in a way that doesn't give\n\t *   these\n\t */\n    public getStroke(index: number): Stroke {\n        if (this.strokes == null) {\n            throw new Error(\"Cannot call getStroke in this state\");\n        }\n\n        return this.strokes[index];\n    }\n\n    /**\n\t * Obtains all the directions (stroke and move).\n\t * @return All the direction arrows\n\t */\n    public getAllDirections(): string {\n        let out = \"\";\n        for (let i = 0; i < this.strokeDirections.length; i++) {\n            if (i > 0) {\n                out += \":\";\n                out += this.moveDirections[i - 1];\n                out += \":\";\n            }\n            out += this.strokeStarts[i];\n            out += this.strokeDirections[i];\n            out += this.strokeEnds[i];\n        }\n        return out;\n    }\n\n    private getTwoDigitPosition(intPos: number): string {\n        let result = intPos.toString(16);\n        if (result.length === 1) {\n            result = \"0\" + result;\n        }\n        return result;\n    }\n\n    /**\n\t * Obtains all stroke details as a from/to summary.\n\t * @return Full details as string\n\t */\n    public getFullSummary(): string {\n        if (this.strokes == null) {\n            throw new Error(\"Strokes not available\");\n        }\n\n        let out = \"\";\n        for (const stroke of this.strokes) {\n            if (out.length > 0) {\n                out += \":\";\n            }\n            out += this.getTwoDigitPosition(stroke.startX);\n            out += \",\";\n            out += this.getTwoDigitPosition(stroke.startY);\n            out += \"-\";\n            out += this.getTwoDigitPosition(stroke.endX);\n            out += \",\";\n            out += this.getTwoDigitPosition(stroke.endY);\n        }\n\n        return out;\n    }\n\n    /**\n\t * Writes the basic info from this kanji to short XML format data.\n\t * @param out Writer that receives data\n\t * @throws IOException Any error\n\t */\n    public write(): KanjiInfoDto {\n        return new KanjiInfoDto(this.kanji, this.getFullSummary());\n\n        // return (\"<kanji unicode='\"\n        //     + (code || 0).toString(16).toUpperCase()\n        //     + \"' strokes='\" + this.getFullSummary() + \"'/>\\n\");\n    }\n\n    /**\n\t * Gets a score for matching with the specified other kanji. Scores are\n\t * only comparable against other kanji with same stroke count.\n\t * @param other Other kanji\n\t * @param algo Match algorithm to use\n\t * @return Score\n\t * @throws IllegalArgumentException If other kanji has inappropriate stroke count\n\t */\n    public getMatchScore(other: KanjiInfo, algo: MatchAlgorithm): number {\n        let comparer = this.comparers.get(algo.key);\n        if (comparer == null) {\n            comparer = algo.newComparer(this);\n            this.comparers.set(algo.key, comparer);\n        }\n\n        return comparer.getMatchScore(other);\n    }\n}\n","import { KanjiInfo } from \"./KanjiInfo\";\n\nexport class KanjiMatch {\n    /**\n     * @param kanji Kanji\n     * @param score Match score (higher is better)\n     */\n    constructor(readonly kanjiInfo: KanjiInfo, readonly score: number) { }\n\n    public static compare(th: KanjiMatch, o: KanjiMatch): number {\n        if (th.score > o.score) {\n            return -1;\n        } else if (th.score < o.score) {\n            return 1;\n        } else {\n            return KanjiMatch.strcmp(th.kanjiInfo.kanji, o.kanjiInfo.kanji);\n        }\n    }\n\n    private static strcmp(a: string, b: string): number {\n        return (a < b ? -1 : (a > b ? 1 : 0));\n    }\n}\n","import { KanjiInfo } from \"./KanjiInfo\";\nimport { KanjiInfoDto } from \"./KanjiInfoDto\";\nimport { MatchAlgorithm } from \"./MatchAlgorithm\";\nimport { KanjiMatch } from \"./KanjiMatch\";\n\n// interface IKanjiInfoMap {\n//   [key: number]: KanjiInfo[];\n// }\n\nexport class KanjiList {\n\n    // private kanji: IKanjiInfoMap = {};\n    public  kanjiInfos = new Map<number, KanjiInfo[]>();\n    private finished = false;\n\n    public isFinished() { return this.finished; }\n\n    /**\n\t * Adds a kanji to the list.\n\t * @param info Kanji to add\n\t */\n    public add(info: KanjiInfo) {\n        const count = info.getStrokeCount();\n        let list: KanjiInfo[] = this.kanjiInfos.get(count);\n        if (list == null) {\n            list = [];\n            this.kanjiInfos.set(count, list);\n        }\n        list.push(info);\n    }\n\n    public finish() {\n        this.kanjiInfos = new Map([...this.kanjiInfos].sort((a, b) => a[0] - b[0]));\n        this.finished = true;\n    }\n\n    private checkFinished() {\n        if (!this.finished) {\n            throw new Error(\"Cannot call on unfinished kanji\");\n        }\n    }\n    /**\n\t * @param strokeCount Stroke count\n\t * @return All kanji with that stroke count\n\t */\n    public getKanji(strokeCount: number): KanjiInfo[] {\n        this.checkFinished();\n        const list = this.kanjiInfos.get(strokeCount);\n        if (list == null) {\n            return [];\n        }\n        return list;\n    }\n\n    /**\n\t * @param search Kanji to find\n\t * @return Info for that kanji\n\t * @throws IllegalArgumentException If kanji does not exist in list\n\t */\n    public find(search: string): KanjiInfo {\n        this.checkFinished();\n        for (const list of this.kanjiInfos.values()) {\n            for (const info of list) {\n                if (info.kanji === search) {\n                    return info;\n                }\n            }\n        }\n        throw new Error(\"Kanji '\" + search + \"' not found\");\n    }\n\n    /**\n\t * Searches for closest matches.\n\t * @param compare Kanji to compare\n\t * @param algo Match algorithm to use\n\t * @param progress Progress reporter (null if not needed)\n\t * @return Top matches above search threshold\n\t * @throws IllegalArgumentException If match algorithm not set\n\t */\n    public getTopMatches(compare: KanjiInfo,\n                         algo: MatchAlgorithm): KanjiMatch[] {\n        this.checkFinished();\n        let matches: KanjiMatch[] = [];\n        const list: KanjiInfo[] = [];\n\n        if (compare.getStrokeCount() > 0) {\n            // Do either -2 and +2, -1 and +1, or just 0\n            const range = algo.out;\n            let count = compare.getStrokeCount() - range;\n            for (let i = 0; i < 2; i++) {\n                if (count > 0) {\n                    const countList = this.kanjiInfos.get(count);\n                    if (countList != null) {\n                        list.push(...countList);\n                    }\n                }\n                count += 2 * range;\n                if (range === 0) {\n                    break;\n                }\n            }\n        }\n\n        for (const other of list) {\n            const score = compare.getMatchScore(other, algo);\n            const match = new KanjiMatch(other, score);\n            matches.push(match);\n        }\n        matches = matches.sort((a, b) => KanjiMatch.compare(a, b));\n\n        // Pull everything down to half match score\n        const results: KanjiMatch[] = [];\n        let maxScore = -1;\n        for (const match of matches) {\n            if (maxScore === -1) {\n                maxScore = match.score;\n            } else {\n                if (match.score < maxScore * 0.75) {\n                    break;\n                }\n            }\n            results.push(match);\n        }\n\n        return results;\n    }\n\n    public load(dtos: KanjiInfoDto[]) {\n        this.kanjiInfos.clear();\n        for (const dto of dtos) {\n            this.add(KanjiInfo.fromFull(dto.kanji, dto.strokes));\n        }\n        this.finish();\n    }\n\n    public save(): KanjiInfoDto[] {\n        this.checkFinished();\n        const output: KanjiInfoDto[] = [];\n        for (const kinfos of this.kanjiInfos.values()) {\n            for (const character of kinfos) {\n                const kinfoDto = character.write();\n                output.push(kinfoDto);\n            }\n        }\n        return output;\n    }\n}\n","import { IKanjiComparer } from \"./KanjiComparer\";\nimport { KanjiInfo } from \"./KanjiInfo\";\nimport { Direction } from \"./Direction\";\nimport { Location } from \"./Location\";\n\n/**\n * Compares entered strokes with other kanji using slightly fuzzy logic.\n */\nexport class StrictComparer implements IKanjiComparer {\n    private static readonly STROKE_DIRECTION_WEIGHT = 1.0;\n    private static readonly MOVE_DIRECTION_WEIGHT = 0.8;\n    private static readonly STROKE_LOCATION_WEIGHT = 0.6;\n\n    private static readonly CLOSE_WEIGHT = 0.7;\n\n    private drawnStarts: Location[];\n    private drawnEnds: Location[];\n    private drawnDirections: Direction[];\n    private drawnMoves: Direction[];\n\n    /**\n\t * Initialises with given drawn kanji.\n\t * @param info Drawn kanji\n\t */\n    public init(info: KanjiInfo) {\n        this.drawnStarts = info.strokeStarts;\n        this.drawnEnds = info.strokeEnds;\n        this.drawnDirections = info.strokeDirections;\n        this.drawnMoves = info.moveDirections;\n    }\n\n    /**\n\t * Compares against the given other kanji.\n\t * @param other Other kanji\n\t * @return Score in range 0 to 100\n\t */\n    public getMatchScore(other: KanjiInfo): number {\n        const otherStarts = other.strokeStarts,\n            otherEnds = other.strokeEnds;\n        const otherDirections = other.strokeDirections,\n            otherMoves = other.moveDirections;\n\n        if (otherStarts.length !== this.drawnStarts.length) {\n            throw new Error(\n                \"Can only compare with same match length\");\n        }\n\n        let score = 0;\n        for (let i = 0; i < this.drawnStarts.length; i++) {\n            // Stroke direction\n            if (this.drawnDirections[i] === otherDirections[i]) {\n                score += StrictComparer.STROKE_DIRECTION_WEIGHT;\n            } else if (this.drawnDirections[i].isClose(otherDirections[i])) {\n                score += StrictComparer.STROKE_DIRECTION_WEIGHT * StrictComparer.CLOSE_WEIGHT;\n            }\n\n            // Move direction\n            if (i > 0) {\n                if (this.drawnMoves[i - 1] === otherMoves[i - 1]) {\n                    score += StrictComparer.MOVE_DIRECTION_WEIGHT;\n                } else if (this.drawnMoves[i - 1].isClose(otherMoves[i - 1])) {\n                    score += StrictComparer.MOVE_DIRECTION_WEIGHT * StrictComparer.CLOSE_WEIGHT;\n                }\n            }\n\n            // Start and end locations\n            if (this.drawnStarts[i] === otherStarts[i]) {\n                score += StrictComparer.STROKE_LOCATION_WEIGHT;\n            } else if (this.drawnStarts[i].isClose(otherStarts[i])) {\n                score += StrictComparer.STROKE_LOCATION_WEIGHT * StrictComparer.CLOSE_WEIGHT;\n            }\n            if (this.drawnEnds[i] === otherEnds[i]) {\n                score += StrictComparer.STROKE_LOCATION_WEIGHT;\n            } else if (this.drawnEnds[i].isClose(otherEnds[i])) {\n                score += StrictComparer.STROKE_LOCATION_WEIGHT * StrictComparer.CLOSE_WEIGHT;\n            }\n        }\n\n        const max = this.drawnStarts.length * (StrictComparer.STROKE_DIRECTION_WEIGHT\n            + 2 * StrictComparer.STROKE_LOCATION_WEIGHT)\n            + (this.drawnStarts.length - 1) * StrictComparer.MOVE_DIRECTION_WEIGHT;\n\n        return 100.0 * score / max;\n    }\n}\n","import { IKanjiComparer } from \"./KanjiComparer\";\nimport { KanjiInfo } from \"./KanjiInfo\";\n\n// tslint:disable-next-line:max-classes-per-file\nexport class FuzzyComparer implements IKanjiComparer {\n\n    private drawnPairs: Pair[];\n    private drawnPoints: Point[];\n\n    public static readonly SCOREMULTI_NOT_PAIR = 0.9;\n    public static readonly SCOREMULTI_WRONG_DIRECTION = 0.97;\n\n    public static readonly BEST_SCORES_SORT_FIRST = 5;\n\n    public init(drawn: KanjiInfo) {\n        // Set up data about drawn pairs/points\n        this.drawnPairs = this.convertKanjiInfo(drawn);\n        this.drawnPoints = this.getPairPoints(this.drawnPairs);\n        for (const pair of this.drawnPairs) {\n            pair.initDrawn(this.drawnPairs.length + 2);\n        }\n    }\n\n    private convertKanjiInfo(info: KanjiInfo): Pair[] {\n        const result: Pair[] = [];\n        for (let i = 0; i < info.getStrokeCount(); i++) {\n            const stroke = info.getStroke(i);\n            result[i] = new Pair(\n                new Point(stroke.startX, stroke.startY),\n                new Point(stroke.endX, stroke.endY));\n        }\n        for (const pair of result) {\n            pair.a.setPair(pair);\n            pair.b.setPair(pair);\n        }\n        return result;\n    }\n\n    private getPairPoints(pairs: Pair[]): Point[] {\n        const result = new Array<Point>(pairs.length * 2);\n        let out = 0;\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < pairs.length; i++) {\n            result[out++] = pairs[i].a;\n            result[out++] = pairs[i].b;\n        }\n        for (const point of result) {\n            point.count(result);\n        }\n        return result;\n    }\n\n    /**\n\t * Compares against the given other kanji.\n\t * @param other Other kanji\n\t * @return Score in range 0 to 100\n\t */\n    public getMatchScore(other: KanjiInfo): number {\n        // Get data from match kanji\n        const otherPairs = this.convertKanjiInfo(other);\n        const otherPoints = this.getPairPoints(otherPairs);\n\n        // Max difference is (less than) the highest number of strokes *\n        // 6 facets.\n        const maxScore = Math.max(this.drawnPoints.length, otherPoints.length) * 6;\n\n        // Score all points against all points; O(points^2)\n        for (const point of this.drawnPoints) {\n            point.calcScore(otherPoints, maxScore);\n        }\n\n        // Score all pairs\n        for (const pair of this.drawnPairs) {\n            pair.calcScore(otherPoints);\n        }\n\n        // Copy source pairs into list of remaining ones\n        const remainingPairs = this.drawnPairs.slice();\n\n        // How many remaining things to match?\n        let pairsLeft = remainingPairs.length;\n        let pointsLeft = otherPoints.length;\n        let totalScore = 0;\n\n        while (pointsLeft > 0 && pairsLeft > 0) {\n            // Score all pairs to find best match\n            let bestPairIndex = -1;\n            let bestPair: Pair = null;\n            let bestPairScore = -1;\n            for (let i = 0; i < remainingPairs.length; i++) {\n                const pair = remainingPairs[i];\n                if (pair == null) {\n                    continue;\n                }\n                pair.scoreAvailable(otherPoints, bestPairScore);\n                if (pair.bestScore > bestPairScore) {\n                    bestPair = pair;\n                    bestPairIndex = i;\n                    bestPairScore = pair.bestScore;\n                }\n            }\n\n            // Eat that pair and its points, and add to total score\n            remainingPairs[bestPairIndex] = null;\n            const aIndex = bestPair.bestAIndex;\n            const bIndex = bestPair.bestBIndex;\n            otherPoints[aIndex] = null;\n            otherPoints[bIndex] = null;\n            totalScore += bestPairScore;\n            pairsLeft--;\n            pointsLeft -= 2;\n        }\n\n        // Scale score (it is now up to 2 * max * number of pairs matched)\n        totalScore /= 2 * maxScore * (this.drawnPairs.length - pairsLeft);\n\n        // Return as percentage\n        return totalScore * 100;\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass Pair {\n    private pointCount: number = 0;\n\n    private scores: number[][];\n    private maxBScore: number = 0;\n    private maxAScore: number = 0;\n\n    public bestScore: number = 0;\n    public bestAIndex: number = 0;\n    public bestBIndex: number = 0;\n\n    constructor(public a: Point, readonly b: Point) {}\n\n    public initDrawn(maxStrokes: number) {\n        this.scores = [];\n        for (let i = 0; i < maxStrokes * 2; i++) {\n            this.scores[i] = new Array<number>(maxStrokes * 2).fill(0);\n        }\n        this.a.initDrawn(maxStrokes);\n        this.b.initDrawn(maxStrokes);\n    }\n\n    public calcScore(availablePoints: Point[]) {\n        this.pointCount = availablePoints.length;\n        this.maxBScore = -1;\n        this.maxAScore = -1;\n\n        // Get max B score\n        for (let bIndex = 0; bIndex < this.pointCount; bIndex++) {\n            const bScore = this.b.score[bIndex];\n            if (bScore > this.maxBScore) {\n                this.maxBScore = bScore;\n            }\n        }\n\n        for (let aIndex = 0; aIndex < this.pointCount; aIndex++) {\n            // Track max A score\n            const aScore = this.a.score[aIndex];\n            if (aScore > this.maxAScore) {\n                this.maxAScore = aScore;\n            }\n            const ap = availablePoints[aIndex];\n            const aPair = ap.pair;\n            const wrongDirection = aPair.a != ap;\n\n            for (let bIndex = 0; bIndex < this.pointCount; bIndex++) {\n                const bScore = this.b.score[bIndex];\n\n                if (bIndex == aIndex) {\n                    continue;\n                }\n\n                // Basic score is sum of individual scores\n                let score = aScore + bScore;\n\n                if (aPair != availablePoints[bIndex].pair) {\n                    score *= FuzzyComparer.SCOREMULTI_NOT_PAIR;\n                } else if (wrongDirection) {\n                    score *= FuzzyComparer.SCOREMULTI_WRONG_DIRECTION;\n                }\n\n                this.scores[aIndex][bIndex] = score;\n            }\n        }\n\n        this.bestScore = -1;\n    }\n\n    public scoreAvailable(otherPoints: Point[], mustBeOver: number) {\n        // If it hasn't changed since last time, do nothing\n        if (this.bestScore > 0) {\n            return;\n        }\n        // If we can't possibly achieve a better score than the current best,\n        // return\n        if (this.maxAScore + this.maxBScore < mustBeOver) {\n            return;\n        }\n\n        // Consider all combinations of point A and B\n        this.bestScore = -1;\n        // \t\t\tint loopCount = 0;\n        for (let aIndex = 0; aIndex < this.pointCount; aIndex++) {\n            const aScore = this.a.sortedScore[aIndex];\n            const aPointIndex = aScore.index;\n            if (aScore.score + this.maxBScore < mustBeOver\n                || otherPoints[aPointIndex] == null) {\n                // If A score + any B score can't beat min score, then continue, or\n                // also if point is done\n                continue;\n            }\n\n            const correspondingScores = this.scores[aPointIndex];\n            for (let bIndex = 0; bIndex < this.pointCount; bIndex++) {\n                const bScore = this.b.sortedScore[bIndex];\n                const bPointIndex = bScore.index;\n                if (bPointIndex == aPointIndex || otherPoints[bPointIndex] == null) {\n                    continue;\n                }\n\n                // \t\t\t\t\tloopCount++;\n\n                // Basic score is sum of individual scores\n                const score = correspondingScores[bPointIndex];\n\n                // Is this best?\n                if (score > this.bestScore) {\n                    this.bestScore = score;\n                    this.bestAIndex = aPointIndex;\n                    this.bestBIndex = bPointIndex;\n\n                    if (this.bestScore > mustBeOver) {\n                        mustBeOver = this.bestScore;\n                    }\n                }\n            }\n        }\n\n        // \t\t\tSystem.err.println(loopCount + \"/\" + (pointCount * pointCount));\n\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass ScoreAndIndex {\n\n    public score: number = 0;\n    public index: number = 0;\n    public used: boolean = false;\n\n    public static compare(th: ScoreAndIndex, o: ScoreAndIndex): number {\n        if (o.score > th.score) {\n            return 1;\n        } else if (o.score < th.score) {\n            return -1;\n        } else {\n            return th.index - o.index;\n        }\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass Point {\n    public static readonly SIMILAR_RANGE = 13;\n\n    private x: number = 0;\n    private y: number = 0;\n    private xLess: number = 0;\n    private xMore: number = 0;\n    private xSimilar: number = 0;\n    private yLess: number = 0;\n    private yMore: number = 0;\n    private ySimilar: number = 0;\n\n    public pair: Pair;\n    public score: number[];\n    public sortedScore: ScoreAndIndex[];\n\n    private preSortedScore: ScoreAndIndex[];\n    private best = new Array<number>(FuzzyComparer.BEST_SCORES_SORT_FIRST).fill(0);\n\n    constructor(x: number, y: number) {\n        this.x = Math.trunc((x + 0.5) * 255);\n        this.y = Math.trunc((y + 0.5) * 255);\n    }\n\n    public setPair(pair: Pair) {\n        this.pair = pair;\n    }\n\n    public count(allPoints: Point[]) {\n        for (const point of allPoints) {\n            if (point !== this) {\n                if (point.x < this.x - Point.SIMILAR_RANGE) {\n                    this.xLess++;\n                } else if (point.x > this.x + Point.SIMILAR_RANGE) {\n                    this.xMore++;\n                } else {\n                    this.xSimilar++;\n                }\n\n                if (point.y < this.y - Point.SIMILAR_RANGE) {\n                    this.yLess++;\n                } else if (point.y > this.y + Point.SIMILAR_RANGE) {\n                    this.yMore++;\n                } else {\n                    this.ySimilar++;\n                }\n            }\n        }\n    }\n\n    public initDrawn(maxStrokes: number) {\n        // Initialise the array only once per drawn character\n        this.score = new Array<number>(maxStrokes * 2); // new int[maxStrokes * 2];\n        this.sortedScore =  new Array<ScoreAndIndex>(maxStrokes * 2); // new ScoreAndIndex[maxStrokes * 2];\n        this.preSortedScore = new Array<ScoreAndIndex>(maxStrokes * 2 + 1); // new ScoreAndIndex[maxStrokes * 2 + 1];\n        for (let i = 0; i < maxStrokes * 2; i++) {\n            this.preSortedScore[i] = new ScoreAndIndex();\n        }\n        // Dummy score to use for 'best' marker\n        this.preSortedScore[maxStrokes * 2] = new ScoreAndIndex();\n    }\n\n    public calcScore(otherPoints: Point[], maxScore: number) {\n        this.stage1(otherPoints, maxScore);\n        this.stage2();\n        this.stage3(otherPoints);\n        // \t\t\tSystem.err.println(Arrays.toString(sortedScore));\n\n        // \t\t\tfor(int i=otherPoints.length; i<sortedScore.length; i++)\n        // \t\t\t{\n        // \t\t\t\tsortedScore[i] = new ScoreAndIndex(0, i);\n        // \t\t\t}\n        //\n        // \t\t\t// Sort score into order\n        // \t\t\tArrays.sort(sortedScore);\n        //          this.sortedScore.sort((a, b) => ScoreAndIndex.compare(a, b));\n    }\n\n    public stage1(otherPoints: Point[], maxScore: number) {\n        for (let i = 0; i < FuzzyComparer.BEST_SCORES_SORT_FIRST; i++) {\n            this.best[i] = this.preSortedScore.length - 1;\n        }\n        let worstBestScore = 0;\n        for (let i = 0; i < otherPoints.length; i++) {\n            const thisScore = this.calcThisScore(maxScore, otherPoints[i]);\n            const pss = this.preSortedScore[i];\n            pss.index = i;\n            pss.score = thisScore;\n            pss.used = false;\n            this.score[i] = thisScore;\n\n            if (thisScore >= worstBestScore) {\n                const bestIndex = this.stage1a(thisScore);\n                this.stage1b(bestIndex);\n                this.best[bestIndex] = i;\n                if (bestIndex == FuzzyComparer.BEST_SCORES_SORT_FIRST - 1) {\n                    worstBestScore = thisScore;\n                }\n            }\n        }\n    }\n\n    public calcThisScore(maxScore: number, other: Point): number {\n        const difference = Math.abs(this.xLess - other.xLess)\n        + Math.abs(this.xMore - other.xMore) + Math.abs(this.xSimilar - other.xSimilar)\n        + Math.abs(this.yLess - other.yLess) + Math.abs(this.yMore - other.yMore)\n        + Math.abs(this.ySimilar - other.ySimilar);\n\n        const thisScore = maxScore - difference;\n        return thisScore;\n    }\n\n    public stage1a(thisScore: number): number {\n        let bestIndex = 0;\n        for (; bestIndex < FuzzyComparer.BEST_SCORES_SORT_FIRST - 1; bestIndex++) {\n            if (thisScore > this.preSortedScore[this.best[bestIndex]].score) {\n                return bestIndex;\n            }\n        }\n        return bestIndex;\n    }\n\n    public stage1b(bestIndex: number) {\n        for (let moveIndex = FuzzyComparer.BEST_SCORES_SORT_FIRST - 1; moveIndex > bestIndex; moveIndex--) {\n            this.best[moveIndex] = this.best[moveIndex - 1];\n        }\n    }\n\n    public stage2() {\n        for (let i = 0; i < FuzzyComparer.BEST_SCORES_SORT_FIRST; i++) {\n            const pss = this.preSortedScore[this.best[i]];\n            this.sortedScore[i] = pss;\n            pss.used = true;\n        }\n    }\n\n    public stage3(otherPoints: Point[]) {\n        let index = FuzzyComparer.BEST_SCORES_SORT_FIRST;\n        for (let i = 0; i < otherPoints.length; i++) {\n            const pss = this.preSortedScore[i];\n            if (!pss.used) {\n                this.sortedScore[index++] = pss;\n            }\n        }\n    }\n}\n","import { IKanjiComparer } from \"./KanjiComparer\";\nimport { KanjiInfo } from \"./KanjiInfo\";\n\nexport class SpansComparer implements IKanjiComparer {\n\n    /**\n     * Number of categories for X and Y. Note: There is one array with (this\n     * number) to power four, so don't increase it too much...\n     */\n    public static LOCATION_RANGE = 5;\n    public static ARRAY_SIZE = SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE;\n\n    public static SCORE_RIGHTDIRECTION = 2;\n    public static SCORE_EXACTLOCATION = 4;\n    public static SCORE_STRAIGHTLOCATION = 3;\n    public static SCORE_DIAGONALLOCATION = 2;\n\n    public static MAX_SCORE = SpansComparer.SCORE_EXACTLOCATION * 2 + SpansComparer.SCORE_RIGHTDIRECTION;\n    public static MIN_SCORE = SpansComparer.SCORE_DIAGONALLOCATION * 2;\n\n    public static NO_MATCH = -1;\n\n    /**\n     * Array of possible matching strokes. The indexes of this array are in\n     * the form startX * LOCATION_RANGE^3 + startY * LOCATION_RANGE^2 +\n     * endX * LOCATION_RANGE + endY\n     */\n    private positions: Position[];\n\n    private count = 0;\n\n    public init(info: KanjiInfo) {\n        // Create positions array\n        this.positions = [];\n        for (let i = 0; i < SpansComparer.ARRAY_SIZE; i++) {\n            this.positions[i] = new Position();\n        }\n\n        // Loop through all the strokes\n        this.count = info.getStrokeCount();\n        for (let i = 0; i < this.count; i++) {\n            const s = info.getStroke(i);\n\n            // Work out X and Y\n            const startX = (s.startX * SpansComparer.LOCATION_RANGE) >> 8;\n            const startY = (s.startY * SpansComparer.LOCATION_RANGE) >> 8;\n            const endX = (s.endX * SpansComparer.LOCATION_RANGE) >> 8;\n            const endY = (s.endY * SpansComparer.LOCATION_RANGE) >> 8;\n\n            this.addSpan(i, startX, startY, endX, endY, true);\n            this.addSpan(i, endX, endY, startX, startY, false);\n        }\n\n        // Finish everything\n        for (let i = 0; i < SpansComparer.ARRAY_SIZE; i++) {\n            this.positions[i].finish();\n        }\n    }\n\n    private getIndex(sX: number, sY: number, eX: number, eY: number): number {\n        return sX * SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE\n            + sY * SpansComparer.LOCATION_RANGE * SpansComparer.LOCATION_RANGE\n            + eX * SpansComparer.LOCATION_RANGE\n            + eY;\n    }\n\n    private addSpan(stroke: number, startX: number, startY: number, endX: number, endY: number,\n                    rightDirection: boolean) {\n        for (let sX = startX - 1; sX <= startX + 1; sX++) {\n            if (sX < 0 || sX >= SpansComparer.LOCATION_RANGE) {\n                continue;\n            }\n            for (let sY = startY - 1; sY <= startY + 1; sY++) {\n                if (sY < 0 || sY >= SpansComparer.LOCATION_RANGE) {\n                    continue;\n                }\n                for (let eX = endX - 1; eX <= endX + 1; eX++) {\n                    if (eX < 0 || eX >= SpansComparer.LOCATION_RANGE) {\n                        continue;\n                    }\n                    for (let eY = endY - 1; eY <= endY + 1; eY++) {\n                        if (eY < 0 || eY >= SpansComparer.LOCATION_RANGE) {\n                            continue;\n                        }\n\n                        // Get score\n                        let score;\n                        if (startX === sX && startY === sY) {\n                            score = SpansComparer.SCORE_EXACTLOCATION;\n                        } else if (startX === sX || startY === sY) {\n                            score = SpansComparer.SCORE_STRAIGHTLOCATION;\n                        } else {\n                            score = SpansComparer.SCORE_DIAGONALLOCATION;\n                        }\n                        if (endX === eX && endY === eY) {\n                            score += SpansComparer.SCORE_EXACTLOCATION;\n                        } else if (endX === eX || endY === eY) {\n                            score += SpansComparer.SCORE_STRAIGHTLOCATION;\n                        } else {\n                            score += SpansComparer.SCORE_DIAGONALLOCATION;\n                        }\n                        if (rightDirection) {\n                            score += SpansComparer.SCORE_RIGHTDIRECTION;\n                        }\n\n                        // Add to positions\n                        this.positions[this.getIndex(sX, sY, eX, eY)].add(stroke, score);\n                    }\n                }\n            }\n        }\n    }\n\n    public getMatchScore(other: KanjiInfo): number {\n        // Set up used array with nothing used\n        const used: boolean[] = []; // new boolean[count]\n        let unmatched = this.count;\n\n        // Convert each stroke ion the target kanji to a position index\n        const otherCount = other.getStrokeCount();\n        let otherUnmatched = otherCount;\n        const otherUsed: boolean[] = [];\n        const otherIndexes: number[] = [];\n\n        for (let i = 0; i < otherCount; i++) {\n            const s = other.getStroke(i);\n\n            // Work out X and Y\n            const startX = (s.startX * SpansComparer.LOCATION_RANGE) >> 8;\n            const startY = (s.startY * SpansComparer.LOCATION_RANGE) >> 8;\n            const endX = (s.endX * SpansComparer.LOCATION_RANGE) >> 8;\n            const endY = (s.endY * SpansComparer.LOCATION_RANGE) >> 8;\n\n            otherIndexes[i] = this.getIndex(startX, startY, endX, endY);\n        }\n\n        // Calculate total score\n        let score = 0;\n\n        // Loop through all the strokes in the other kanji and try to match them\n        // Begin with max score\n        for (let requiredScore = SpansComparer.MAX_SCORE; requiredScore >= SpansComparer.MIN_SCORE; requiredScore--) {\n            for (let i = 0; i < otherCount; i++) {\n                if (otherUsed[i]) {\n                    continue;\n                }\n\n                const match = this.positions[otherIndexes[i]].match(requiredScore, used);\n                if (match !== SpansComparer.NO_MATCH) {\n                    // Add score\n                    score += requiredScore;\n\n                    // Mark it as used\n                    otherUsed[i] = true;\n                    used[match] = true;\n                    unmatched--;\n                    otherUnmatched--;\n                    if (unmatched === 0 || otherUnmatched === 0) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        // Work out as a proportion of max possible score\n        const maxScore = Math.min(this.count, otherCount) * SpansComparer.MAX_SCORE;\n        return 100 * (score / maxScore);\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass SpanScore {\n    /**\n     * @param stroke Index of stroke within drawn kanji\n     * @param score Score of this combination (how closely it reflects the stroke)\n     */\n    constructor(readonly stroke: number, readonly score: number) { }\n\n    public static compare(th: SpanScore, other: SpanScore): number {\n        if (other.score > th.score) {\n            return 1;\n        } else if (other.score < th.score) {\n            return -1;\n        }\n        return other.stroke - th.stroke;\n    }\n}\n\n// tslint:disable-next-line:max-classes-per-file\nclass Position {\n    private spanSet: SpanScore[] = [];\n    private spanScores: SpanScore[];\n\n    public add(stroke: number, score: number) {\n        this.spanSet.push(new SpanScore(stroke, score));\n    }\n\n    public finish() {\n        this.spanScores = this.spanSet.sort((a, b) => SpanScore.compare(a, b));\n        this.spanSet = null;\n    }\n\n    /**\n     * Returns the id of the stroke that matches this position at this score\n     * or NO_MATCH if none\n     * @param minScore Required score\n     * @param used Array of used strokes\n     * @return Stroke index or NO_MATCH if nothing with that score\n     */\n    public match(minScore: number, used: boolean[]): number {\n        for (const score of this.spanScores) {\n            if (score.score < minScore) {\n                return SpansComparer.NO_MATCH;\n            }\n            if (!used[score.stroke]) {\n                return score.stroke;\n            }\n        }\n        return SpansComparer.NO_MATCH;\n    }\n}\n","import { IKanjiComparer } from \"./KanjiComparer\";\nimport { KanjiInfo } from \"./KanjiInfo\";\nimport { StrictComparer } from \"./StrictComparer\";\nimport { FuzzyComparer } from \"./FuzzyComparer\";\nimport { SpansComparer } from \"./SpansComparer\";\n\nexport type MatchAlgorithmKey = \"STRICT\" | \"FUZZY\" | \"FUZZY_1OUT\" | \"FUZZY_2OUT\" | \"SPANS\" | \"SPANS_1OUT\" | \"SPANS_2OUT\";\n\ninterface IKanjiComparerConstructor {\n    new(): IKanjiComparer;\n}\n\n/**\n* Algorithm used for comparing kanji.\n*/\nexport class MatchAlgorithm {\n\n    /**\n     * Accurate, fast, but strict algorithm (requires precise stroke count\n     * and order).\n     */\n    public static readonly STRICT = new MatchAlgorithm(\"STRICT\", 0, StrictComparer);\n\n    /**\n    * Fuzzy matching algorithm which allows arbitrary stroke order. Very slow.\n    */\n    public static readonly FUZZY = new MatchAlgorithm(\"FUZZY\", 0, FuzzyComparer);\n\n    /**\n    * Fuzzy matching algorithm which allows arbitrary stroke order; with\n    * either +1 or -1 stroke count (does not include =). Even slower.\n    */\n    public static readonly FUZZY_1OUT = new MatchAlgorithm(\"FUZZY_1OUT\", 1, FuzzyComparer);\n    /**\n    * Fuzzy matching algorithm which allows arbitrary stroke order; with\n    * either +2 or -2 stroke count. Also slow\n    */\n    public static readonly FUZZY_2OUT = new MatchAlgorithm(\"FUZZY_2OUT\", 2, FuzzyComparer);\n\n    /**\n    * Second fuzzy matching algorithm based on the 'spans' created by each\n    * stroke.\n    */\n    public static readonly SPANS = new MatchAlgorithm(\"SPANS\", 0, SpansComparer);\n\n    /**\n    * Second fuzzy matching algorithm based on the 'spans' created by each\n    * stroke.\n    * Allows +1 or -1 stroke count.\n    */\n    public static readonly SPANS_1OUT = new MatchAlgorithm(\"SPANS_1OUT\", 1, SpansComparer);\n\n    /**\n    * Second fuzzy matching algorithm based on the 'spans' created by each\n    * stroke.\n    * Allows +2 or -2 stroke count.\n    */\n    public static readonly SPANS_2OUT = new MatchAlgorithm(\"SPANS_2OUT\", 2, SpansComparer);\n\n    constructor(readonly key: MatchAlgorithmKey, readonly out: number, readonly ctor: IKanjiComparerConstructor) { }\n\n    /**\n    * Constructs a new comparer object with the given drawn kanji\n    * @param drawn Drawn kanji\n    * @return Comparer object, already inited\n    */\n    public newComparer(drawn: KanjiInfo): IKanjiComparer {\n        let comparer: IKanjiComparer;\n        try {\n            comparer = new this.ctor();\n        } catch {\n            throw new Error(\"Incorrectly defined comparer\");\n        }\n        comparer.init(drawn);\n        return comparer;\n    }\n}\n","\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue } from \"vue-property-decorator\";\nimport signature_pad from \"signature_pad\";\nimport pako from \"pako\";\nimport { KanjiList } from \"../src/KanjiList\";\nimport { KanjiInfo } from \"../src/KanjiInfo\";\nimport { InputStroke } from \"../src/InputStroke\";\nimport { MatchAlgorithm } from \"../src/MatchAlgorithm\";\n\n@Component({})\nexport default class App extends Vue {\n    public isLoading = true;\n    public message = \"Loading\";\n\n    // drawing pad\n    private pad!: signature_pad;\n    private canvas!: HTMLCanvasElement;\n\n    // bootstrap variants for controls\n    public variant = \"700\";\n    public variantOutline = \"outline-700\";\n\n    // buttons state\n    public clearDisabled = true;\n    public undoDisabled = true;\n    public algoText = \"FUZZY\";\n\n    public readonly kanjiResults1: any[] = [];\n    public readonly kanjiResults2: any[] = [];\n    public readonly kanjiResults3: any[] = [];\n\n    // logic\n    private kanjiList: KanjiList;\n    private inputStrokes: InputStroke[] = [];\n    private startX: number;\n    private startY: number;\n    private endX: number;\n    private endY: number;\n\n    private  readonly jpws = \"\";\n\n    constructor() {\n        super();\n\n        const instr = \"\";\n        for (let i = 0; i < 10; i++) {\n            this.kanjiResults1.push({ index: i, kanji: instr[i] });\n            this.kanjiResults2.push({ index: i, kanji: instr[i + 10] });\n            this.kanjiResults3.push({ index: i, kanji: instr[i + 20] });\n        }\n    }\n\n    // dynamic component\n    public $refs!: {\n        signaturePadCanvas: HTMLCanvasElement;\n        actionsLeft: HTMLDivElement;\n        algoMode: HTMLDivElement;\n    };\n\n    public clear() {\n        this.pad.clear();\n        this.inputStrokes = [];\n        this.clearKanjiResults();\n    }\n\n    public undo() {\n        const data = this.pad.toData();\n        if (data) {\n            data.pop(); // remove the last dot or line\n            this.inputStrokes.pop();\n            this.pad.fromData(data);\n\n            const hasStrokes = this.inputStrokes.length > 0;\n\n            this.undoDisabled = this.clearDisabled = !hasStrokes; // disable buttons if empty after\n            if (!hasStrokes) {\n                this.clearKanjiResults();\n            } else {\n                this.searchKanji();\n            }\n        }\n    }\n\n    private clearKanjiResults() {\n        this.kanjiResults1.forEach((kr) => kr.kanji = this.jpws);\n        this.kanjiResults2.forEach((kr) => kr.kanji = this.jpws);\n        this.kanjiResults3.forEach((kr) => kr.kanji = this.jpws);\n    }\n\n    private searchKanji() {\n        const potentialKanji = new KanjiInfo(\"?\");\n        for (const is of this.inputStrokes) {\n            potentialKanji.addStroke(is);\n        }\n        potentialKanji.finish();\n\n        const matches = this.kanjiList.getTopMatches(potentialKanji, MatchAlgorithm.FUZZY).slice(0, 30);\n        console.log(matches);\n        for (let i = 0; i < 10; i++) {\n            this.kanjiResults1[i].kanji = (matches[i]) ? matches[i].kanjiInfo.kanji : this.jpws;\n            this.kanjiResults2[i].kanji = (matches[i + 10]) ? matches[i + 10].kanjiInfo.kanji : this.jpws;\n            this.kanjiResults3[i].kanji = (matches[i + 20]) ? matches[i + 20].kanjiInfo.kanji : this.jpws;\n        }\n    }\n\n    // lifecycle hook\n    public mounted() {\n        this.$nextTick(() => {\n            // Code that will run only after the\n            // entire view has been rendered\n            window.addEventListener(\"resize\", this.resizeCanvas);\n\n            this.canvas = this.$refs.signaturePadCanvas;\n\n            this.pad = new signature_pad(this.canvas, {\n                onBegin: (evt) => {\n                    this.startX = evt.clientX;\n                    this.startY = evt.clientY;\n                },\n                onEnd: (evt) => {\n                    this.endX = evt.clientX;\n                    this.endY = evt.clientY;\n                    this.undoDisabled = this.clearDisabled = false;\n\n                    const stroke = InputStroke.fromFloats(this.startX, this.startY, this.endX, this.endY);\n                    this.inputStrokes.push(stroke);\n\n                    this.searchKanji();\n                    // this.$emit(\"input\", this.pad.toDataURL());\n                },\n            });\n\n            this.fetchKanjiList()\n                .then((kanjiList) => {\n                    if (kanjiList.isFinished()) {\n                        this.kanjiList = kanjiList;\n                        this.isLoading = false;\n\n                        // isLoading = false will bring in the canvas\n                        // but we can only resize it after it has been rendered\n                        this.$nextTick(() => {\n                            this.resizeCanvas();\n                        });\n                    }\n                });\n        });\n    }\n\n    private resizeCanvas() {\n        // When zoomed out to less than 100%, for some very strange reason,\n        // some browsers report devicePixelRatio as less than 1\n        // and only part of the canvas is cleared then.\n        const ratio =  Math.max(window.devicePixelRatio || 1, 1);\n        this.canvas.width = this.canvas.offsetWidth * ratio;\n        this.canvas.height = this.canvas.offsetHeight * ratio;\n        this.canvas.getContext(\"2d\").scale(ratio, ratio);\n        // This library does not listen for canvas changes, so after the canvas is automatically\n        // cleared by the browser, SignaturePad#isEmpty might still return false, even though the\n        // canvas looks empty, because the internal data of this library wasn't cleared. To make sure\n        // that the state of this library is consistent with visual state of the canvas, you\n        // have to clear it manually.\n        this.pad.clear();\n    }\n\n    public copyKanji(kanji: string) {\n        if (!kanji) {\n            return;\n        }\n        const textArea = document.createElement(\"textarea\");\n        textArea.value = kanji;\n        textArea.style.cssText = \"position:fixed;pointer-events:none;z-index:-9999;opacity:0\";\n        document.body.appendChild(textArea);\n        textArea.select();\n        try {\n            document.execCommand(\"copy\");\n        } catch (err) {\n            console.warn(err);\n        }\n        document.body.removeChild(textArea);\n    }\n\n    private fetchKanjiList(): Promise<KanjiList> {\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            const url = \"data/strokes.dat\";\n            xhr.open(\"GET\", url, true);\n            xhr.responseType = \"arraybuffer\";\n            xhr.send();\n\n            xhr.onload = (evt) => {\n                if (xhr.status > 0 && xhr.status !== 200) {\n                    reject({\n                        status: xhr.status,\n                        statusText: xhr.statusText,\n                    });\n                    return;\n                }\n\n                const bin = xhr.response;\n                const json = pako.inflate(new Uint8Array(bin), { to: \"string\" });\n\n                // KanjiInfoDto stricly not required since\n                // we are the producer of strokes.dat\n                // const dtos: KanjiInfoDto[] = JSON.parse(json);\n                const dtos = JSON.parse(json);\n                const kanjiList = new KanjiList();\n                kanjiList.load(dtos);\n\n                // log a sample\n                console.log(kanjiList.getKanji(1));\n\n                resolve(kanjiList);\n            };\n        });\n    }\n}\n","import mod from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"; export default mod; export * from \"-!../node_modules/cache-loader/dist/cjs.js??ref--13-0!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js!../node_modules/ts-loader/index.js??ref--13-3!../node_modules/vue-loader/lib/index.js??vue-loader-options!./App.vue?vue&type=script&lang=ts&\"","import { render, staticRenderFns } from \"./App.vue?vue&type=template&id=1ed68c86&\"\nimport script from \"./App.vue?vue&type=script&lang=ts&\"\nexport * from \"./App.vue?vue&type=script&lang=ts&\"\nimport style0 from \"./App.vue?vue&type=style&index=0&lang=scss&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\ncomponent.options.__file = \"App.vue\"\nexport default component.exports","import Vue from \"vue\";\nimport App from \"./App.vue\";\n// import store from \"./src/store\";\nimport BootstrapVue from \"bootstrap-vue\";\n\nVue.use(BootstrapVue);\n\nVue.config.productionTip = false;\n\nnew Vue({\n  // store,\n  render: (h) => h(App),\n}).$mount(\"#app\");\n"],"sourceRoot":""}